\documentclass[a4paper,12pt]{article}
%\usepackage{amsthm}
%\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{corollary}{Corollary}[thm]
\newtheorem{prf}{Proof}[thm]
\newtheorem{defn}{Definition}[section]
\newtheorem{exmp}{Example}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
\usepackage{siunitx}
\usepackage{microtype}
\usepackage{float}
\usepackage{graphicx}
\usepackage{bm}
\usepackage{commath}
\usepackage{amsmath}
\usepackage{parskip}
\usepackage{longtable}
\usepackage{enumerate}
\graphicspath{}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{cleveref}
\linespread{1.3}
\usepackage{tabulary}
\usepackage{listings}
\usepackage{xcolor} % for setting colors

% set the default code style
\lstset{
  language=C++,
  frame=tb, % draw a frame at the top and bottom of the code block
  tabsize=4, % tab space width
  showstringspaces=false, % don't mark spaces in strings
    %numbers=left, % display line numbers on the left
  commentstyle=\color{green}, % comment color
  keywordstyle=\color{blue}, % keyword color
  stringstyle=\color{red}, % string color
  basicstyle=\ttfamily\lst@ifdisplaystyle\footnotesize\fi,
  basewidth = {.48em}
}
\newcommand*{\diff}{\mathop{}\!\mathbf{d}}
\newcommand*{\hlinebreak}{\rule{\textwidth}{1pt}}
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=\parskip \thm@postskip=0pt
}
\makeatother
\title{Professional C++ notes}
\date{\today}
\author{Anas Syed}

\begin{document}
\maketitle
\tableofcontents
\newcommand{\sectionbreak}{\clearpage}

\section{Basics}
\subsection{Preprocessor directives}

\lstinline|#pragma| is not standard across all compilers, so don't use it.

\hlinebreak
\begin{lstlisting}[caption={Prevent circular includes}]
#ifndef [key]
#define [key]
//code
#endif
\end{lstlisting}

\subsection{Casting}
\begin{enumerate}
  \item \lstinline|bool someBool = (bool)someInt;|
  \item \lstinline|bool someBool = bool(someInt);|
  \item \label{itm:static_cast} \lstinline|bool someBool = static_cast<bool>(someInt);|
\end{enumerate}
\Cref{itm:static_cast} is considered to be the cleanest.

\subsection{Structs}
Structs are the same as classes in \verb|C++|, except the default access specifier for a struct is public, whereas for a class it's private. If we define a struct as follows:

\begin{lstlisting}
struct employee {
  int age;
  float salary;
  char initial;
} employee1, employee2;
\end{lstlisting}

then when we call the struct in \verb|C|, we must prefix \verb|employee| with \verb|struct|. In \verb|C++|, this is optional. Alternatively, in \verb|C|, we can \verb|typedef| the struct:

\begin{lstlisting}
typedef struct {
  int age;
  float salary;
  char initial;
} employee;
employee employee1, employee2;
\end{lstlisting}

or

\begin{lstlisting}
struct employee {
  int age;
  float salary;
  char initial;
} employee1, employee2;
typedef struct employee employee;
\end{lstlisting}
\subsection{Stack and heap}
The stack is a Last in First out data structure. If you call a function \lstinline|foo()|, then all of the static variables (those not created using \lstinline|new| or \lstinline|malloc|) in \lstinline|foo| exist in a stack frame. If \lstinline|foo| was called from \lstinline|main|, then you cannot easily change or access the static variables in the stack frame of \lstinline|foo| from within \lstinline|main|, because they are in a different stack frame.

However, if you allocate some dynamic memory to a variable in \lstinline|foo|, then you could access or modify this variable in main.
\subsubsection{Freeing memory}
When you allocate memory with the \lstinline|new| operator, you must eventually free it with \lstinline|delete|. Note that this even applies to \lstinline|int| objects. For example, the following code has a 4 byte memory leak:

\begin{lstlisting}[caption={Memory leak}]
int main() {
  int* a = new int(5);
}
\end{lstlisting}

Running \lstinline|valgrind --tool=memcheck ./a.out| gives the error message:
\begin{lstlisting}[language=bash, caption={Valgrind output}]
==11934== Memcheck, a memory error detector
==11934== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==11934== Using Valgrind-3.10.1 and LibVEX; rerun with -h for copyright info
==11934== Command: ./a.out
==11934== 
==11934== 
==11934== HEAP SUMMARY:
==11934==     in use at exit: 4 bytes in 1 blocks
==11934==   total heap usage: 1 allocs, 0 frees, 4 bytes allocated
==11934== 
==11934== LEAK SUMMARY:
==11934==    definitely lost: 4 bytes in 1 blocks
==11934==    indirectly lost: 0 bytes in 0 blocks
==11934==      possibly lost: 0 bytes in 0 blocks
==11934==    still reachable: 0 bytes in 0 blocks
==11934==         suppressed: 0 bytes in 0 blocks
==11934== Rerun with --leak-check=full to see details of leaked memory
==11934== 
==11934== For counts of detected and suppressed errors, rerun with: -v
==11934== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
\end{lstlisting}
See \url{http://www.cprogramming.com/debugging/valgrind.html} for more information on Valgrind.

On the other hand, the following does not create a leak:
\begin{lstlisting}[caption={No memory leak}]
int main() {
  int a = int(5);
}
\end{lstlisting}

\subsection{Strings}
\subsubsection{C style}
\begin{lstlisting}
char arrayString[20] = "Hello, World"; //allocates 20 bytes
char* pointerString = "Hello, World"; //allocates 13 bytes
\end{lstlisting}

Use \lstinline|#include <cstring>| for standard \verb|C| library functions.
\subsubsection{C++ style}
\begin{lstlisting}
#include <string>
int main() {
  std::string str1 = "Hello";
  std::string str2 = str1 + ", World";
}
\end{lstlisting}
\subsection{Exceptions}
\begin{lstlisting}
#include <iostream>
#include <stdexcept>

double divideNumbers(double inNumerator, double inDenominator) {
  if (inDenominator == 0) {
    throw std::exception();
  }
  return (inNumerator / inDenominator);
}

int main(int argc, char** argv) {
  try {
    std::cout << divideNumbers(2.3, 0) << std::endl;
  } catch (std::exception exception) {
    std::cout << "An exception was caught!" << std::endl;
  }
}
\end{lstlisting}

\section{Object oriented programming}
\subsection{Access specifiers}
Any method of the class can call a protected method and access a protected member. Methods of a subclass can call a protected method or access a protected member of an object.
\subsection{Reminder of syntax}
\begin{lstlisting}[caption={SpreadsheetCell.h}]
class SpreadsheetCell {
  public:
    SpreadsheetCell();
    ~SpreadsheetCell();
    double getValue();
  private:
    double mValue;
};
\end{lstlisting}
\begin{lstlisting}[caption={SpreadsheetCell.cpp}]
#include "SpreadsheetCell.h"
SpreadsheetCell::SpreadsheetCell() : mValue(0) {
  std::cout << "Creating cell" << std::endl;
}

SpreadsheetCell::~SpreadsheetCell() {
  std::cout << "Destroying cell " << mValue << std::endl;
}

double SpreadsheetCell::getValue() {
  return (mValue);
}
\end{lstlisting}
\subsection{Creating objects on the stack or heap}
\begin{lstlisting}[caption={Creating objects on the stack}]
SpreadsheetCell myCell, anotherCell;
\end{lstlisting}
\begin{lstlisting}[caption={Creating objects on the heap}]
SpreadsheetCell* myCellp = new SpreadsheetCell();
//run some code
delete myCellp; //Don't forget to deallocate memory
\end{lstlisting}

\subsection{Constructors}
\textbf{Whenever an object is created, one of its constructors \emph{must} be called.}

Say we had a constructor as follows:
\begin{lstlisting}
SpreadsheetCell::SpreadsheetCell(double initialValue) {
  setValue(initialValue);
}
\end{lstlisting}
Then to create an object on the stack, we must do the following:
\begin{lstlisting}
SpreadsheetCell myCell(5), anotherCell(4);
\end{lstlisting}
The following do not work:
\begin{lstlisting}
SpreadsheetCell myCell.SpreadsheetCell(5); // WILL NOT COMPILE!
//or
SpreadsheetCell myCell;
myCell.SpreadsheetCell(5); // WILL NOT COMPILE!
\end{lstlisting}

And for allocation on the heap, use
\begin{lstlisting}
SpreadsheetCell *myCellp = new SpreadsheetCell(5);
SpreadsheetCell *anotherCellp;
anotherCellp = new SpreadsheetCell(4);
delete anotherCellp;
\end{lstlisting}

For overloaded constructors, calling one constructor from another does not apply to the variable of the outer constructor (as expected). The following code shows this problem:

\begin{lstlisting}
SpreadsheetCell::SpreadsheetCell(string initialValue) {
  SpreadsheetCell(stringToDouble(initialValue));
  //Does not call the constructor for this object
}
\end{lstlisting}

\subsubsection{Initialiser lists}
Consider a class as follows:
\begin{lstlisting}
class SpreadsheetCell {
  public:
    SpreadsheetCell();
    SpreadsheetCell(int mValue, string mString);
  private;
    int mValue;
    string mString;
}
\end{lstlisting}

Now one way of implementing the default constructor is as follows:
\begin{lstlisting}
SpreadsheetCell::SpreadsheetCell () : mValue(0), mString("") {
}
\end{lstlisting}

And the other constructor:

\begin{lstlisting}[caption={C++ gets it right with the name clash}, label={lst:initialiserList}]
SpreadsheetCell::SpreadsheetCell (int mValue, string mString) : mValue(mValue),
  mString(mString) {
}
\end{lstlisting}

Note that this is different to the following:

\begin{lstlisting}
SpreadsheetCell::SpreadsheetCell (int mValue, string mString){
  this->mValue = mValue;
  this->mString = mString;
}
\end{lstlisting}

Once the body of the constructor has been entered, all member objects and parent objects have already been created. So \lstinline|this->mValue = mValue| modifies the value of the existing \lstinline|mValue| object. In listing \ref{lst:initialiserList}, the default constructor for an \lstinline|int| is not called, but it is constructed with the correct value right from the start by calling a non-default constructor. This is more efficient and allows one to initialise member objects by something other than their default constructor.

The constructor for the parent class is called first. The order in which the constructor calls to the remaining elements in the initialiser lists are executed is determined by the order in which they are declared in the class definition.

\Cref{tab:initialiserMandatory} shows the objects for which inclusion in the initialiser list is mandatory.
\begin{table}
  \centering
  \begin{tabulary}{\textwidth}{|L|L|}
    \hline
    {\bf Data type} & {\bf Explanation} \\ \hline
    const data members & You cannot legally assign a value to a const variable after it is created. Any value must be supplied at the time of creation \\ \hline
    Reference data members & References cannot exist without referring to something. \\ \hline
    Object data members for which there is no default constructor & C++ attempts to initialize member objects using a default constructor. If no default constructor exists, it cannot initialize the object. \\ \hline
    Superclasses without default constructors & The superclass must be initialised before the constructor begins execution \\ \hline
  \end{tabulary}
  \caption{Objects which must be included in the initialiser list}
  \label{tab:initialiserMandatory}
\end{table}

See {\footnotesize\url{http://www.cprogramming.com/tutorial/initialization-lists-c++.html}} for an alternative explanation.

\subsubsection{Copy constructors}
An example of a copy constructor:
\begin{lstlisting}
SpreadsheetCell::SpreadsheetCell(const SpreadsheetCell& src) :
mValue(src.mValue), mString(src.mString) {
}
\end{lstlisting}
If you don't write a copy constructor, one is not written for you. The one that the compiler writes for you is not always suitable, especially when you have memory being dynamically allocated on the heap from within the object methods. More on this in %\cref{..}

The copy constructor is implicitly called whenever you pass an object by value to a function. It can also be called explicitly like \lstinline|SpreadsheetCell myCell(anotherCell);|.
\subsection{Default constructors}
A default constructor is required if you want to be able to declare an object but not initialise it, like \lstinline|SpreadsheetCell myCell|. Use a default constructor on the stack like so:

\begin{lstlisting}
SpreadsheetCell myCell;
myCell.setValue(6);
\end{lstlisting}

A word of warning: do not call the default constructor with parentheses when creating the object on the stack. The following is incorrect:

\begin{lstlisting}[numbers=left]
SpreadsheetCell myCell(); // WRONG, but will compile.
myCell.setValue(6); // However, this line will not compile.
\end{lstlisting}

Line 1 does compile. This is because the compiler thinks that you are declaring a function called \lstinline|myCell| which returns a \lstinline|SpreadsheetCell| and takes no arguments. The next line doesn't compile because the compiler thinks you are trying to call a method on the function!
\vspace{\baselineskip}
\begin{center}
  \noindent\fbox{%
    \parbox{0.9\textwidth}{%
      \textbf{When creating an object on the stack, omit parenthesis for the default constructor.}
    }%
  }
\end{center}
\vspace{\baselineskip}
But when using the default constructor to create objects on the heap, you should use the functional syntax:

\begin{lstlisting}
SpreadsheetCell* myCellp = new SpreadsheetCell(); // Note the function-call syntax
\end{lstlisting}

\subsubsection{When you need a default constructor}
\paragraph{Arrays}
If there is no default constructor for \lstinline|SpreadsheetCell|, the following fail:

\begin{lstlisting}
SpreadsheetCell cells[2]; // FAILS compilation without a default constructor
SpreadsheetCell* myCellp = new SpreadsheetCell[10]; // Also FAILS
\end{lstlisting}

There is no syntax to specify a different constructor for all elements. For stack based arrays, one can construct each element individually as follows:

\begin{lstlisting}[caption={Example of \emph{initialisers}}]
SpreadsheetCell cells[2] = {SpreadsheetCell(0), SpreadsheetCell(23)};
\end{lstlisting}

There is no such syntax for heap based arrays.

\paragraph{Creating objects inside another class}
If you have a class as follows:

\begin{lstlisting}
class twoCats {
  private:
    cat firstCat;
    cat secondCat;
};
\end{lstlisting}
Then either the class \lstinline|cat| must have a default constructor, or every constructor for \lstinline|twoCats| must initialise \lstinline|firstCat| and \lstinline|secondCat| with a non-default constructor of \lstinline|cat| explicitly.

\paragraph{Subclasses}
It is convenient for a superclass to have a default constructor, as this makes the construction of subclasses simpler, as subclasses must always call a constructor of their respective superclass, in which case, having a default constructor for the superclass can be useful.


\end{document}
